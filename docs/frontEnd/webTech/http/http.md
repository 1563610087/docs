# http基础



## 1 HTTP

http协议是超文本传输协议，是用于从万维网服务器传输文本到本地浏览器的传送协议，是基于tcp/ip通信协议来传输数据的。

http原理，http协议是作用在客户端和服务器端上的，电脑上的浏览器是作为http客服端通过使用url向http服务器端（web服务器）发送所有的请求。

web服务器接收到由http客户端发送的请求后，向客户端发送响应信息，http默认的端口号为80端口（之间的通风口）。

**http的特点**：

1.**简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、PUT、DELETE、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

2.**灵活**：HTTP允许传输任意类型的数据对象。

3.**无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

4.**无状态**：**HTTP协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。**直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息。**这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的**。

### 2 消息结构

http是基于客户端和服务器端C/S的架构模型，是一个无状态的请求/响应协议，客户端通过连接服务器，向服务器发送一个或多个http的请求，服务器端通过接收客户端的请求并向客服端发送http响应数据。

注：url为统一资源标识符，是用来传输数据和建立连接的。

客户端发送一个HTTP请求到服务器的请求消息：

包含有：请求行，请求头部，空行，请求数据四种
（请求行，请求头部，请求数据）

服务器响应消息：

http响应消息包含：状态行，响应头，空行，响应体

### 3 请求方法

![img](https://mmbiz.qpic.cn/mmbiz/3aPj0GhFQDBot7Vk0BmsWGQAcibV2qoSU3AMkoZf6C8WWbh8SAWLO1KJ0W2QaSLCdUCXu7icbnMF0gj3Fwto8a0g/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz/3aPj0GhFQDBot7Vk0BmsWGQAcibV2qoSUiaibQLHsoKxAXnD8Cm4l4yR0cy5CIb61EDbRkQghf3e2BZS8jFicZt95g/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

| 方法    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| get     | GET请求会显示请求指定的资源，一般由于数据资源的读取操作，在url末尾可以追加查询字符串，请求的body中只能包含很少数据，依据浏览器和服务器的不同而不同 |
| post    | 主要用来向服务器新增数据，请求的主体理论上可以包含任意多数据 |
| head    | HEAD与GET方法一样，只是不返回报文的主体部分，主要用于确认url的有效性及资源更新的日期时间。判断类型、查看响应中的状态码、测试资源是否被修改过、查看服务器性能 |
| put     | 用来传输文件，在请求报文的主体内容中包含文件内容，保存到请求URL指定的位置，http1.1的PUT方法自身不带验证机制，任何人都可以请求，上传文件，会有安全问题 |
| delete  | 删除服务器上某个资源                                         |
| options | 查询服务器支持的请求方法                                     |
| trace   | 可以对请求消息的传输路径进行追踪                             |
| connect | 要求在与代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl(安全套接层)和tls(传输层安全)协议把通信内容加密后经网络隧道传输 |
| patch   | 与PUT请求类似，同样用于资源的更新，但有两点不同，一是PATCH一般用于资源的部分更新，而PUT用于资源的整体更新；二是当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已存在的资源进行更新 |

1 get和post区别

1、GET参数通过URL传递，POST放在Request body中。

2、GET请求会被浏览器主动cache，而POST不会，除非手动设置。

3、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。post更安全

4、Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符。

5  Get 请求发送数据时，URL 的长度是受限制的（URL 的最大长度是 2048 个字符），这个限制，url 长度限制是某些浏览器和服务器的限制，和 HTTP 协议没有关系

2 put和post区别

都可以用于资源的更新和创建

post主要用于创建资源

put用于更新资源，为冥等

### 4 HTTP首部

|     通用字段      |                       作用                       |
| :---------------: | :----------------------------------------------: |
|   Cache-Control   |                  控制缓存的行为                  |
|    Connection     | 浏览器想要优先使用的连接类型，比如  `keep-alive` |
|       Date        |                   创建报文时间                   |
|      Pragma       |                     报文指令                     |
|        Via        |                代理服务器相关信息                |
| Transfer-Encoding |                   传输编码方式                   |
|      Upgrade      |                要求客户端升级协议                |
|      Warning      |               在内容中可能存在错误               |

|      请求字段       |                作用                |
| :-----------------: | :--------------------------------: |
|       Accept        |        能正确接收的媒体类型        |
|   Accept-Charset    |         能正确接收的字符集         |
|   Accept-Encoding   |      能正确接收的编码格式列表      |
|   Accept-Language   |        能正确接收的语言列表        |
|       Expect        |        期待服务端的指定行为        |
|        From         |           请求方邮箱地址           |
|        Host         |            服务器的域名            |
|      If-Match       |          两端资源标记比较          |
|  If-Modified-Since  | 本地资源未修改返回 304（比较时间） |
|    If-None-Match    | 本地资源未修改返回 304（比较标记） |
|     User-Agent      |             客户端信息             |
|    Max-Forwards     |    限制可被代理及网关转发的次数    |
| Proxy-Authorization |      向代理服务器发送验证信息      |
|        Range        |        请求某个内容的一部分        |
|       Referer       |    表示浏览器所访问的前一个页面    |
|         TE          |            传输编码方式            |

|      响应字段      |            作用            |
| :----------------: | :------------------------: |
|   Accept-Ranges    |   是否支持某些种类的范围   |
|        Age         | 资源在代理缓存中存在的时间 |
|        ETag        |          资源标识          |
|      Location      |   客户端重定向到某个 URL   |
| Proxy-Authenticate |  向代理服务器发送验证信息  |
|       Server       |         服务器名字         |
|  WWW-Authenticate  |   获取资源需要的验证信息   |

|     实体字段     |              作用              |
| :--------------: | :----------------------------: |
|      Allow       |       资源的正确请求方式       |
| Content-Encoding |         内容的编码格式         |
| Content-Language |         内容使用的语言         |
|  Content-Length  |       request body 长度        |
| Content-Location |       返回数据的备用地址       |
|   Content-MD5    | Base64加密格式的内容 MD5检验值 |
|  Content-Range   |         内容的位置范围         |
|   Content-Type   |         内容的媒体类型         |
|     Expires      |         内容的过期时间         |
|  Last_modified   |       内容的最后修改时间       |

### 5  状态码

##### 100-199  信息性状态码

- 100    说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。
- 101    说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议

##### 200-299   成功状态码

- 200   请求没有问题，实体的主体部分包含了所请求的资源
- 201   用于创建服务器对象的请求(比如PUT)。响应的实体主体部分中应该包含各种引用了已创建资源的URL,Location首部包含的则是具体的引用
- 202   请求已被接受，但服务器还未对其执行任何动作
- 203   实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本
- 204   响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新(比如刷新一个表单页面)
- 205   负责告知浏览器清除当前页面中的所有HTML表单元素
- 206   成功执行了一个部分或Range(范围)请求。

##### 300-399  重定向状态码

- 300   客户端请求一个实际指向多个资源的URL时会返回这个状态码
- 301   在请求的URL已被移除时使用。响应的Location首部中应包含资源现在所处的URL
- 302   与301类似。但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL
- 303   告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去
- 304   如果客户端发起了一个条件GET请求，而最近资源未被修改的话，则可以用这个状态码说明资源未被修改。带有这个状态码的响应不应该包含实体的主体部分
- 305   用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出。
- 307   与301类似。但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL

##### 400-499  客户端错误状态码

- 400  用于告知客户端它发送了一个错误的请求，请求报文中存在语法错误
- 401  表示发送的请求需要通过HTTP认证(BASIC认证、DIGIST认证)的认证信息
- 403  对请求资源的访问被服务器拒绝了。如未获得文件系统的访问授权，访问权限出现某些问题等
- 404  说明服务器无法找到请求的URL
- 405  请求中带有所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，已告知客户端应对所请求的资源而已使用哪些方法
- 406  客户端可以指定参数来说明它们愿意接收什么类型的实体
- 407  与401类似，但要求对资源进行认证的代理服务器
- 408  如果客户端完成请求所花时间太长，服务器可以回送此状态码，并关闭连接
- 409  说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。响应中包含描述冲突的主体
- 410  与404类似，只是服务器曾经拥有过此资源。主要用于web站点维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了
- 411  服务器要求在请求报文中包含Content-Length首部时使用
- 412  客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了Except首部时发起的请求就是条件请求
- 413  客户端发送的实体主体部分比服务器能够希望处理的要大时，使用此状态码
- 414  客户端所发请求中的请求URL比服务器能够或者希望处理的要大时，使用此状态码
- 415  服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码
- 416  请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码
- 417  请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码

##### 500-599  服务器错误状态码

- 500  服务器在执行请求时发生了错误。也有可能是web应用存在但bug或某些临时的故障
- 501  客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)
- 502  作为代理或网关使用的服务器从请求响应链的下一链路上收到了一条伪响应(比如，它无法连接到其父网关)
- 503  表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
- 504  与状态码408类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了
- 505  服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码

### 6 content-type

Content-Type，内容类型
一般指网页中存在的Content-Type
用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件

## 2 TCP和UDP

### 2.1 TCP/IP 网络模型

TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。

TCP/IP 模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。

- 链路层：负责封装和解封装 IP 报文，发送和接受 ARP/RARP 报文等。
- 网络层：负责路由以及把分组报文发送给目标网络或主机。
- 传输层：负责对报文进行分组和重组，并以 TCP 或 UDP 协议格式封装报文。
- 应用层：负责向用户提供应用程序，比如 HTTP、FTP、Telnet、DNS、SMTP 等。
- 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍 TCP/IP 中有两个具有代表性的传输层协议----TCP 和 UDP。

### 2.2 UDP

UDP 协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。基于udp的应用层协议有TFTP，SNMP、DNS

它有以下几个特点：

#### 1.面向无连接

首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。不会对数据报文进行任何拆分和拼接操作。

具体来说就是：

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

#### 2.面向报文

数据以数据报文的形式传输

发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文

#### 3.传输方式

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

#### 4.不可靠性

* 不可靠性体现在无连接上，通信都不需要建立连接，想发就发，并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。
*  UDP 因为没有流量控制和拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

#### 5.头部开销小，传输数据报文时是很高效的。

UDP 头部包含了以下几个数据：

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的

### 2.3 TCP

TCP 协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。

#### 1.TCP 连接过程

如下图所示，可以看到建立一个 TCP 连接的过程为（三次握手的过程）:

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

#### 2.TCP 断开链接

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

**第一次握手**

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

**第二次握手**

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

**第三次握手**

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

**第四次握手**

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

#### 3.TCP 协议的特点

- 面向连接

面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

- 仅支持单播传输

每条 TCP 传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。

- 面向字节流

TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

- 可靠传输

对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

- 提供拥塞控制

当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞

- TCP 提供全双工通信

TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）

### 2.4 TCP 和 UDP 的比较

#### 1.对比

|              | UDP                                         | TCP                                    |
| ------------ | ------------------------------------------- | -------------------------------------- |
| 是否连接     | 无连接                                      | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制        | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                       |
| 传输方式     | 面向报文                                    | 面向字节流                             |
| 首部开销     | 首部开销小，仅 8 字节                       | 首部最小 20 字节，最大 60 字节         |
| 适用场景     | 适用于实时应用（IP 电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |



## 3 数据提交方式

HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。

传参的方式主要有两种：且这两种方式主要是通过改变请求头的**Content-Type**属性来实现的，一般请求默认使用**application/x-www-form-urlencoded**编码数据，此时传参形式为**Form Data**，如果是**application/json**或**multipart/form-data**的话，则传参形式为 **request payload**
 的方式。

### 3.1  Form Data

* application/x-www-form-urlencoded

浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。这种编码格式的特点是：name/value值对，每组之间使用&连接，而name与value之间是使用 = 连接，比如 key=xxx&name=111&password=123456;

```
请求类似于下面这样（无关的请求头在本文中都省略掉了）：

POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3

```

首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。

### 3.2   request payload

* multipart/form-data

这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例：

* application/json

由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。

**注意**

当请求头的Content-Type为application/json时浏览器认为该请求为复杂请求，这时浏览器会先进行一次预请求,执行一次OPTIONS 请求，向服务器求证该请求是否合法，如果服务器没有给出正确回应浏览器会报跨域请求导致请求失败

一般这三种方式会导致这种现象:

1:请求的方法不是GET/HEAD/POST

2:POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain

3:请求设置了自定义的header字段

## 4 https

<https://github.com/ljianshu/Blog/issues/50>

### 4.1 概念

HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

HTTPS主要作用是：

（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;

（2）对网站服务器进行真实身份认证。

### 4.2 http缺点

在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下
HTTP协议存在的哪些问题：

- 通信使用明文（不加密），内容可能被窃听

由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，**HTTP报文使用明文（指未经过加密的报文）方式发送**。

HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。

- 无法证明报文的完整性，所以可能遭篡改

所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。
换句话说，**没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的**。

- 不验证通信方的身份，因此有可能遭遇伪装

**HTTP协议中的请求和响应不会对通信方进行确认**。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）

HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。

反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:

- 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
- 数据完整性：内容传输经过完整性校验
- 身份认证：第三方无法伪造服务端（客户端）身份

### 4.3 https原理

HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。

通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。

![img](https://camo.githubusercontent.com/bc68b43bedae8c477d60a33171b0473b5a19dd4c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438323335666135666232323f773d35343326683d32343826663d706e6726733d3431353433)

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。

[![img](https://camo.githubusercontent.com/1c7afca845277a8ce764c76a655cea82e83dd2f9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438363063306564653033333f773d35333926683d33303026663d706e6726733d3238373238)](https://camo.githubusercontent.com/1c7afca845277a8ce764c76a655cea82e83dd2f9/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438363063306564653033333f773d35333926683d33303026663d706e6726733d3238373238)

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，**其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性**。

[![img](https://camo.githubusercontent.com/b32dec1943a87bf12fe2e20ab9fb77e3104c7987/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438626337376565363966383f773d35363126683d32393726663d706e6726733d313430313839)](https://camo.githubusercontent.com/b32dec1943a87bf12fe2e20ab9fb77e3104c7987/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32322f313637643438626337376565363966383f773d35363126683d32393726663d706e6726733d313430313839)

#### 1.加密

HTTPS采用对称加密和非对称加密两者并用的混合加密机制。

使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

具体做法是：**发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。

#### 2.数字签名

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。

**数字签名有两种功效**：

- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
- 数字签名能确定消息的完整性,证明数据是否未被篡改过。

**数字签名如何生成:**
[![img](https://camo.githubusercontent.com/2b83f22cb8a5960e0c776f0c8fec399cdad66a71/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343561306230643738646631353f773d37303426683d33303926663d706e6726733d3232333433)](https://camo.githubusercontent.com/2b83f22cb8a5960e0c776f0c8fec399cdad66a71/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343561306230643738646631353f773d37303426683d33303926663d706e6726733d3232333433)

将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。

**校验数字签名流程**：

[![img](https://camo.githubusercontent.com/744665fb8cc279700e1438ce75781300794cef45/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343561333730356534616264613f773d35383126683d34323026663d706e6726733d3234333738)](https://camo.githubusercontent.com/744665fb8cc279700e1438ce75781300794cef45/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343561333730356534616264613f773d35383126683d34323026663d706e6726733d3234333738)

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。

此时就需要引入了**证书颁发机构**（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。

#### 3.数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。
[![img](https://camo.githubusercontent.com/ab3a531be2a14d196fbb246ef610ba7384822c31/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637643934373132613563656230653f773d34313726683d33313326663d706e6726733d3937373635)](https://camo.githubusercontent.com/ab3a531be2a14d196fbb246ef610ba7384822c31/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637643934373132613563656230653f773d34313726683d33313326663d706e6726733d3937373635)
我们来介绍一下数字证书认证机构的业务流程：

- 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;
- CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
- 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;
- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
- 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。

### 4.4、 HTTPS工作流程

[![img](https://camo.githubusercontent.com/149d65173b307d424c78a93987dbfdaeb4f8722c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343538333963656163626235323f773d3138333426683d3130383026663d706e6726733d313537363832)](https://camo.githubusercontent.com/149d65173b307d424c78a93987dbfdaeb4f8722c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f32322f313661343538333963656163626235323f773d3138333426683d3130383026663d706e6726733d313537363832)

1.Client发起一个HTTPS（比如`https://juejin.im/user/5a9a9cdcf265da238b7d771c`）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。

2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。

3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。

5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。

6.Server使用对称密钥加密“明文内容A”，发送给Client。

7.Client使用对称密钥解密响应的密文，得到“明文内容A”。

8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。

### 4.5、HTTP 与 HTTPS 的区别

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

[![img](https://camo.githubusercontent.com/b72c207ad8cb1ed819b57b05f49106c9ab8275a5/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f31382f313661333131636462383631623530343f773d37363026683d31343626663d706e6726733d3438343638)](https://camo.githubusercontent.com/b72c207ad8cb1ed819b57b05f49106c9ab8275a5/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f342f31382f313661333131636462383631623530343f773d37363026683d31343626663d706e6726733d3438343638)
关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。

- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
- HTTPS需要用到SSL证书，而HTTP不用;
- HTTPS标准端口443，HTTP标准端口80;
- HTTPS基于传输层，HTTP基于应用层;
- HTTPS在浏览器显示绿色安全锁，HTTP没有显示;

### 4.6、HTTPS的缺点

既然HTTPS那么安全可靠，那为何不所有的Web网站都使用HTTPS？

#### 1、技术方面

使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。

而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。

最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

#### 2、经济方面

（1）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

（2）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名

（3）HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。

（4）与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。

（5）HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。

## 5 http2.0

### 5.1 http/1.x的缺点

- 线头阻塞：TCP连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。
- 多个TCP连接
   虽然HTTP/1.1管线化可以支持请求并发，但是浏览器很难实现，chrome、firefox等都禁用了管线化。所以1.1版本请求并发依赖于多个TCP连接，建立TCP连接成本很高，还会存在慢启动的问题。
- 头部冗余，采用文本格式
   HTTP/1.X版本是采用文本格式，首部未压缩，而且每一个请求都会带上cookie、user-agent等完全相同的首部。
- 客户端需要主动请求

### 5.2 http2.0

#### 1 二进制传输

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。**HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码**。

接下来我们介绍几个重要的概念：

- 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；
- 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
- 帧：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

优点：

在单链接多资源方式中，减少了服务端的链接压力，内存占用更少，链接吞吐量更大。这一点可以结合下文中的多路复用来体会。另一方面，由于TCP链接的减少而使网络拥塞状态得以改善，同时慢启动时间的减少。使拥塞和丢包恢复的速度更快。

#### 2.多路复用

在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

大家可以通过 [该链接](https://http2.akamai.com/demo) 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。
[![img](https://camo.githubusercontent.com/5b1c419a000e1c91e21e89e98ca45c2932f218b7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f31342f313638656339303834366635363666623f773d36383026683d34303026663d67696626733d353135383036)](https://camo.githubusercontent.com/5b1c419a000e1c91e21e89e98ca45c2932f218b7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f31342f313638656339303834366635363666623f773d36383026683d34303026663d67696626733d353135383036)
在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

这一特性，使性能有了极大提升：

- 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。
- 并行交错地发送多个请求，请求之间互不影响。
- 并行交错地发送多个响应，响应之间互不干扰。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

[![img](https://camo.githubusercontent.com/f890478d84809b5ba4744818ab707723ca730ad0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32372f313639326661323965343133343866373f773d37343526683d33353826663d706e6726733d3834373230)](https://camo.githubusercontent.com/f890478d84809b5ba4744818ab707723ca730ad0/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f322f32372f313639326661323965343133343866373f773d37343526683d33353826663d706e6726733d3834373230)
如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。

#### 3.Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：

- HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值

例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

#### 4.Server Push

Server Push即服务端能通过push的方式将客户端需要的内容预先推送过去，也叫“cache push”。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch。
例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。

#### 5 资源的优先级

把HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。

每个流都可以带有一个31bit的优先值：0表示最高优先级；2的31次方-1表示最低优先级。

客户端明确指定优先级，服务端可以根据这个优先级作为交互数据的依据，比如客户端优先设置为.css>.js>.jpg。服务端按此顺序返回结果更加有利于高效利用底层连接，提高用户体验。然而，在使用请求优先级时应注意服务端是否支持请求优先级，是否会引起队首阻塞问题，比如高优先级的慢响应请求会阻塞其他资源的交互

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
  具体如图：

   

![img](http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/0?wx_fmt=png)

 

服务器推送到底是什么？
服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：

- 普通的客户端请求过程：

![img](http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribkZLpDyHlTbAGkEiazqLfjkTSfMgib2UlC0p3Yw0T3iaaHcvLjL22PZWPg/0?wx_fmt=png)

 

- 服务端推送的过程：

 

![img](http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribq79os9yK2JmEODZqRVBweS7uMP2WWz4Ij6Z1f9TuiaXANOozhwCWljw/0?wx_fmt=png)

 

 

**为什么需要头部压缩？**
假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍

**HTTP2.0多路复用有多好？**
HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

1. 

